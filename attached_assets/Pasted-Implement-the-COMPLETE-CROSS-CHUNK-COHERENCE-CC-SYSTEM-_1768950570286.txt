Implement the COMPLETE CROSS-CHUNK COHERENCE (CC) SYSTEM exactly as described in the provided document. This replaces any existing coherence code.

First, delete:
- server/services/coherence/ (entire folder)
- Any references/calls to processDocumentCoherently, coherenceProcessor, coherenceMeter, coherenceDatabase, or old coherence logic in routes.ts or other files
- Any frontend coherence components like coherence-progress.tsx

Create new folder: server/services/reconstruction/

Run this SQL in Neon Postgres (safe, idempotent — skips if exists):
CREATE TABLE IF NOT EXISTS reconstruction_jobs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id TEXT NOT NULL,
    document_title TEXT,
    original_text TEXT NOT NULL,
    total_input_words INTEGER NOT NULL,
    target_min_words INTEGER NOT NULL,
    target_max_words INTEGER NOT NULL,
    target_mid_words INTEGER NOT NULL,
    length_ratio DECIMAL NOT NULL,
    length_mode TEXT NOT NULL,
    num_chunks INTEGER NOT NULL,
    chunk_target_words INTEGER NOT NULL,
    global_skeleton JSONB,
    custom_instructions TEXT NOT NULL,
    status TEXT NOT NULL DEFAULT 'pending',
    current_chunk INTEGER NOT NULL DEFAULT 0,
    final_output TEXT,
    final_word_count INTEGER,
    created_at TIMESTAMP NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP NOT NULL DEFAULT NOW()
);

CREATE TABLE IF NOT EXISTS reconstruction_chunks (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    job_id UUID NOT NULL REFERENCES reconstruction_jobs(id) ON DELETE CASCADE,
    chunk_index INTEGER NOT NULL,
    chunk_input_text TEXT NOT NULL,
    chunk_input_words INTEGER NOT NULL,
    target_words INTEGER NOT NULL,
    min_words INTEGER NOT NULL,
    max_words INTEGER NOT NULL,
    chunk_output_text TEXT,
    actual_words INTEGER,
    chunk_delta JSONB,
    retry_count INTEGER NOT NULL DEFAULT 0,
    status TEXT NOT NULL DEFAULT 'pending',
    error_message TEXT,
    created_at TIMESTAMP NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP NOT NULL DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_jobs_status ON reconstruction_jobs(status);
CREATE INDEX IF NOT EXISTS idx_jobs_user ON reconstruction_jobs(user_id);
CREATE INDEX IF NOT EXISTS idx_chunks_job_id ON reconstruction_chunks(job_id);
CREATE INDEX IF NOT EXISTS idx_chunks_status ON reconstruction_chunks(status);
CREATE INDEX IF NOT EXISTS idx_chunks_index ON reconstruction_chunks(job_id, chunk_index);

Implement all code in server/services/reconstruction/ using Drizzle for DB.

Create reconstructionDb.ts with table definitions and helpers: createJob, updateJob, getJob, createChunk, updateChunk, getPendingChunks, getCompletedChunks.

Implement initializeJob, extractSkeleton, processAllChunks (with sleeps, retries, logging target vs actual), stitchAndAssemble, runReconstruction, resumeReconstruction exactly as in code snippets.

Implement prompt builders: buildSkeletonPrompt, buildChunkPrompt, buildRetryPrompt, buildStitchPrompt using exact templates.

Add word count function (split(/\s+/).length).

Add sleep function (async function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }).

Integrate into routes.ts: POST /api/reconstruct {originalText, customInstructions, documentTitle?} calls runReconstruction, returns jobId. GET /api/reconstruction/:jobId polls status/output.

Enforce all critical rules: no parallel chunks, save after each, sleep 2-3s between, retry if <80% min, no memory for chunks, flag conflicts.

Test with small input (2k words, target 1k) — expect skeleton + chunks + stitch, 5-10 min time.

Confirm each part logs correctly and DB gets populated.